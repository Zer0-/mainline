{-# LANGUAGE NamedFieldPuns #-}

module Architecture.Internal.Sub
    ( Received (..)
    , updateSubscriptions
    , openUDPPort
    , connectTCP
    , ciToAddr
    ) where

import Control.Monad (foldM)
import qualified Data.Map as Map
import qualified Data.Set as Set
import Network.Socket
    ( Socket
    , socket
    , SocketType (Stream, Datagram)
    , SockAddr (..)
    , Family (AF_INET)
    , AddrInfo (addrFlags, addrFamily, addrSocketType, addrAddress)
    , AddrInfoFlag (AI_PASSIVE)
    , defaultProtocol
    , defaultHints
    , getAddrInfo
    , bind
    , listen
    , connect
    , close
    , accept
    , hostAddressToTuple
    , tupleToHostAddress
    )
import Network.Socket.ByteString (recv, recvFrom)
import System.Timeout (timeout)
import Data.Hashable (hash)
import qualified Data.ByteString as BS
import Data.Time.Clock.POSIX (getPOSIXTime)
import Control.Concurrent (forkIO, ThreadId)
import Control.Concurrent.STM (TVar, newTVar, atomically)

import Architecture.Internal.Types
    ( InternalState (..)
    , Config (..)
    , Received (..)
    , TSub (..)
    , SubHandler (..)
    , Sub (..)
    )
import Network.Octets (octets)
import Network.KRPC.Types (Port, CompactInfo (CompactInfo))
import Network.Octets (fromOctets)

--MAXLINE = 65507 -- Max size of a UDP datagram
--(limited by 16 bit length part of the header field)
maxline :: Int
maxline = 1472 -- 1500 MTU - 20 byte IPv4 header - 8 byte UDP header

--In Î¼s
udpTimeout :: Int
udpTimeout = 10 * (((^) :: Int -> Int -> Int) 10 6)


-- Need config for:
--  - need the model to apply the subscription message to
--      (I think these are the meat of our app, ideally this forked thread performs it)
--  - ignore Cmd
--  - need update for the same op as #1
--  - subscriptions function is applied to the new model, and the Subs are
--      sent to the main thread to updateSubscriptions

updateSubscriptions
    :: Config model msg
    -> InternalState msg
    -> Sub msg
    -> IO (InternalState msg)
updateSubscriptions cfg istate (Sub tsubs) = do
    return istate

    where
        loads =
            filter (\(k, _) -> Map.notMember k (readThreadS istate)) tsubpairs

        tsubpairs = zip tsubkeys tsubs

        tsubkeys = map hash tsubs


subscribe
    :: Config model msg
    -> TSub msg
    -> IO (SubHandler msg, ThreadId)
subscribe cfg (UDP p h) = do
    th <- atomically (newTVar h)
    sock <- openUDPPort p
    let tHandler = UDPHandler th
    threadId <- forkIO (runUDPSub cfg sock tHandler)
    return (tHandler, threadId)


runUDPSub :: Config model msg -> Socket -> SubHandler msg -> IO ()
runUDPSub cfg sock tHandler = do
    return ()
    --(bs, sockAddr) <- recvFrom boundSocket maxline
    -- we need the model and update function to apply our msg to
    -- - atomically:
    --   - get model
    --   - get handler
    --   - apply handler to bytes, getting message
    --   - apply message to model via update function to get Cmd
    --   - write model
    --
    -- - runCmds on the Cmd
    -- - get model
    -- - write Sub generated by subscription
    -- - runUDPSub


bindSocket :: SocketType -> Port -> IO Socket
bindSocket t p = do
    addr:_ <- getAddrInfo (Just hints) Nothing (Just $ show p)
    sock <- socket AF_INET t defaultProtocol
    bind sock (addrAddress addr)
    return sock

    where
        hints :: AddrInfo
        hints = defaultHints
            { addrFlags = [AI_PASSIVE]
            , addrFamily = AF_INET
            , addrSocketType = t
            }


-- Used by servers
openTCPPort :: Port -> IO Socket
openTCPPort p = do
    sock <- bindSocket Stream p
    listen sock 5
    return sock


-- Used by clients
connectTCP :: CompactInfo -> IO Socket
connectTCP ci = do
    sock <- socket AF_INET Stream defaultProtocol
    connect sock (ciToAddr ci)
    return sock


openUDPPort :: Port -> IO Socket
openUDPPort = bindSocket Datagram


closem :: Maybe Socket -> IO ()
closem = maybe (return ()) close


addrToCi :: SockAddr -> CompactInfo
addrToCi (SockAddrInet port host) =
    CompactInfo
        (fromOctets
            $ (\(a1, a2, a3, a4) -> [a1, a2, a3, a4])
            $ hostAddressToTuple host)
        (fromIntegral port)

addrToCi _ = undefined

ciToAddr :: CompactInfo -> SockAddr
ciToAddr (CompactInfo ip p) = SockAddrInet
    (fromIntegral p)
    (tupleToHostAddress
        $ (\[a1, a2, a3, a4] -> (a1, a2, a3, a4))
        $ octets ip)

