{-# LANGUAGE NamedFieldPuns #-}

module Architecture.Internal.Sub
    ( Received (..)
    , updateSubscriptions
    , openUDPPort
    , connectTCP
    , ciToAddr
    ) where

import Prelude hiding (init)
import Control.Monad (foldM)
import qualified Data.Map as Map
import qualified Data.Set as Set
import Network.Socket
    ( Socket
    , socket
    , SocketType (Stream, Datagram)
    , SockAddr (..)
    , Family (AF_INET)
    , AddrInfo (addrFlags, addrFamily, addrSocketType, addrAddress)
    , AddrInfoFlag (AI_PASSIVE)
    , defaultProtocol
    , defaultHints
    , getAddrInfo
    , bind
    , listen
    , connect
    , close
    , accept
    , hostAddressToTuple
    , tupleToHostAddress
    )
import Network.Socket.ByteString (recv, recvFrom)
import System.Timeout (timeout)
import Data.Hashable (hash)
import qualified Data.ByteString as BS
import Data.Time.Clock.POSIX (getPOSIXTime)
import Control.Concurrent (forkIO, ThreadId)
import Control.Concurrent.STM (TVar, newTVar, atomically, readTVarIO)

import Architecture.Internal.Types
    ( InternalState (..)
    , Config (..)
    , Received (..)
    , TSub (..)
    , SubHandler (..)
    , Sub (..)
    )
import Network.Octets (octets)
import Network.KRPC.Types (Port, CompactInfo (CompactInfo))
import Network.Octets (fromOctets)

--MAXLINE = 65507 -- Max size of a UDP datagram
--(limited by 16 bit length part of the header field)
maxline :: Int
maxline = 1472 -- 1500 MTU - 20 byte IPv4 header - 8 byte UDP header

--In μs
udpTimeout :: Int
udpTimeout = 10 * (((^) :: Int -> Int -> Int) 10 6)


-- what happens if we subscribe first, then a command wants to send from that socket?
-- the thread spawning the write thread for that socket will not have a place to
-- get the existing socket from
updateSubscriptions
    :: Config model msg
    -> InternalState msg
    -> IO (InternalState msg)
updateSubscriptions cfg istate = do
    model <- readTVarIO $ fst $ init cfg
    let (Sub tsubs) = (subscriptions cfg) model

    (newsocks, loaded) <- foldM fsub (Map.empty, Map.empty) (loads tsubs)
    return istate { readThreadS = Map.union loaded (readThreadS istate) }

    where
        loads tsubs =
            filter ( \(k, _)
                    -> Map.notMember k (readThreadS istate)
                   )
                   (tsubpairs tsubs)

        tsubpairs ts = [ ((hash t), t) | t <- ts ]

        fsub (s, m) (k, t) = subscribe cfg t
            >>= (\(va, vb) -> return $ (Map.insert k va s, Map.insert k vb m))


-- TODO:
--  - have this return the created Socket ✓
--  - pass the TVar'd writeThreadS to subscribe and to the main method of the thread
--    so it can call runCmds on it.
--  - same with subSink so we can pass the new Sub to the main thread
--  - same with cmdSink, required by runCmds
--  - before that we have to change runCmds to not have the entire InternalState
subscribe
    :: Config model msg
    -> TSub msg
    -> IO (Socket, (SubHandler msg, ThreadId))
subscribe cfg (UDP p h) = do
    th <- atomically (newTVar h)
    sock <- openUDPPort p
    let tHandler = UDPHandler th
    threadId <- forkIO (runUDPSub cfg sock tHandler)
    return (sock, (tHandler, threadId))


runUDPSub :: Config model msg -> Socket -> SubHandler msg -> IO ()
runUDPSub cfg sock tHandler = do
    --(bs, sockAddr) <- recvFrom sock maxline
    --now <- getPOSIXTime

    return ()
    --(bs, sockAddr) <- recvFrom boundSocket maxline
    -- we need the model and update function to apply our msg to
    -- - atomically:
    --   - get model
    --   - get handler
    --   - apply handler to bytes, getting message
    --   - apply message to model via update function to get Cmd
    --   - write model
    --
    -- - runCmds on the Cmd
    -- - get model
    -- - write Sub generated by subscription
    -- - runUDPSub


bindSocket :: SocketType -> Port -> IO Socket
bindSocket t p = do
    addr:_ <- getAddrInfo (Just hints) Nothing (Just $ show p)
    sock <- socket AF_INET t defaultProtocol
    bind sock (addrAddress addr)
    return sock

    where
        hints :: AddrInfo
        hints = defaultHints
            { addrFlags = [AI_PASSIVE]
            , addrFamily = AF_INET
            , addrSocketType = t
            }


-- Used by servers
openTCPPort :: Port -> IO Socket
openTCPPort p = do
    sock <- bindSocket Stream p
    listen sock 5
    return sock


-- Used by clients
connectTCP :: CompactInfo -> IO Socket
connectTCP ci = do
    sock <- socket AF_INET Stream defaultProtocol
    connect sock (ciToAddr ci)
    return sock


openUDPPort :: Port -> IO Socket
openUDPPort = bindSocket Datagram


closem :: Maybe Socket -> IO ()
closem = maybe (return ()) close


addrToCi :: SockAddr -> CompactInfo
addrToCi (SockAddrInet port host) =
    CompactInfo
        (fromOctets
            $ (\(a1, a2, a3, a4) -> [a1, a2, a3, a4])
            $ hostAddressToTuple host)
        (fromIntegral port)

addrToCi _ = undefined

ciToAddr :: CompactInfo -> SockAddr
ciToAddr (CompactInfo ip p) = SockAddrInet
    (fromIntegral p)
    (tupleToHostAddress
        $ (\[a1, a2, a3, a4] -> (a1, a2, a3, a4))
        $ octets ip)

